{
  "meta": {
    "schema_version": "2.0.0"
  },
  "false_positives": [
    {
      "id": "GEN-FP-001",
      "title": "SSRF via unvalidated upload URL from trusted Storacha bridge",
      "finding_id": "10e17d6d-6ec4-4970-950b-71fc63aadac3",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Trusted upstream only",
      "false_positive_reasoning": "The PUT target URL is obtained exclusively from the Storacha bridge at a hardcoded HTTPS endpoint and is not influenced by user input. Exploitation would require compromise of the Storacha bridge service or TLS/infra, which is outside the application threat model. The code sets explicit timeouts, does not read response bodies for exfiltration, and operates per provider spec.",
      "gap_explanation": "Scanner flagged unvalidated dynamic URL use without considering the trusted, hardcoded upstream and lack of attacker-controlled input paths.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/providers/ipfs/storacha.py",
      "code_snippet": "        store_out = resp_json[0]['p']['out']\n        if 'ok' in store_out:\n            store_result = store_out['ok']\n        else:\n            error_msg = f\"Storacha store/add error: {json.dumps(store_out)}\"\n            logger.error(error_msg)\n            raise UploadError(error_msg)\n\n        if store_result['status'] == 'upload':\n            upload_url = store_result['url']\n            upload_headers = store_result['headers']\n\n            try:\n                upload_response = requests.put(upload_url, headers=upload_headers, data=car_file.car_bytes, timeout=self.timeout)\n                upload_response.raise_for_status()",
      "line_numbers": "lines 85–100",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "staking_liquid_staking",
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "ssrf",
        "ipfs",
        "storacha",
        "s3-presigned"
      ],
      "patterns": [
        "trusted-peer-scope"
      ],
      "taint_source": "network_peer"
    },
    {
      "id": "GEN-FP-016",
      "title": "Log Forgery via Metadata Override in JsonFormatter",
      "finding_id": "e1f2d3c4-5b6a-7890-1a2b-3c4d5e6f7081",
      "severity_claimed_by_scan": "LOW",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Merging untrusted input into log metadata (theoretical collision)",
      "false_positive_reasoning": "In production the logger only merges internally constructed dictionaries; there is no path for attacker-controlled input to supply the top-level metadata fields. The observed collision in the PoC is not exploitable under the current threat model.",
      "gap_explanation": "Scanner flagged potential collisions due to merge order; actual inputs are controlled by the app, not by external users.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/metrics/logging.py",
      "code_snippet": "to_json_msg = json.dumps({\\n            'timestamp': int(record.created),\\n            'name': record.name,\\n            'levelname': record.levelname,\\n            'funcName': record.funcName,\\n            'lineno': record.lineno,\\n            'module': record.module,\\n            'pathname': record.pathname,\\n            **message,\\n        })",
      "line_numbers": "lines 30-39",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "security",
        "logging",
        "json",
        "metadata",
        "fp"
      ],
      "patterns": [
        "log-format",
        "metadata-override"
      ],
      "taint_source": "internal"
    },
    {
      "id": "GEN-FP-017",
      "title": "Transaction Replay Risk Due to Missing Explicit chainId in tx_params",
      "finding_id": "undefined-0000-0000-0000",
      "severity_claimed_by_scan": "MEDIUM",
      "bug_category": "Security",
      "gap_category": "Code Quality",
      "technical_gap": "Implicit chainId binding via Web3/eth-account defaults; no explicit chainId in TxParams",
      "false_positive_reasoning": "The transaction parameters omit chainId, but the signing path binds the chain through the Web3 provider and the eventual signing process; the code uses EIP-1559 fields and relies on provider chain_id. The scanner flagged a potential replay risk due to missing explicit chainId, but there is an implicit binding and cross-provider chain-id checks at startup; no exploitable path exists under the current threat model.",
      "gap_explanation": "Scanner flagged missing explicit chainId; actual signer binds chainId via Web3 provider. Additional hardening is optional.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/web3py/extensions/tx_utils.py",
      "code_snippet": "params: TxParams = {\\n    \"from\": account.address,\\n    \"maxFeePerGas\": Wei(\\n        latest_block[\"baseFeePerGas\"] * 2 + max_priority_fee\\n    ),\\n    \"maxPriorityFeePerGas\": max_priority_fee,\\n    \"nonce\": self.w3.eth.get_transaction_count(account.address),\\n}",
      "line_numbers": "lines 78–85",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "staking_liquid_staking",
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "web3",
        "tx_utils",
        "chainid",
        "security"
      ],
      "patterns": [
        "chainid-implicit"
      ],
    "taint_source": "internal"
    },
    {
      "id": "GEN-FP-002",
      "title": "SSRF via User-Controlled OpsGenie API URL",
      "finding_id": "652bdb9d-a277-40a0-8514-e5480626dd48",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Operator-controlled environment variable",
      "false_positive_reasoning": "The reported SSRF requires an attacker to control the process environment variable `OPSGENIE_API_URL`. In this project the value is read from `os.getenv` and is operator/runtime-controlled (set by deployment or CI). There is no code path that allows untrusted user input to influence this environment variable. Exploitation would require prior compromise of deployment/CI or operator-controlled configuration, which falls outside the application's threat model.",
      "gap_explanation": "Scanner treated an operator-configured environment variable as attacker-controlled input; the project sources `OPSGENIE_API_URL` only from process environment and uses it in a test-runner hook to send alerts.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/utils/api/opsgenie.py",
      "code_snippet": "        if not self.api_key or not self.api_url:\\n            self.logger.info({'msg': 'OpsGenie not configured, ignore.'})\\n            return\\n\\n        headers = {\\n            'Authorization': f'GenieKey {self.api_key}',\\n            'Content-Type': 'application/json',\\n        }\\n\\n        try:\\n            response = requests.post(\\n                f'{self.api_url}/v2/alerts',\\n                json=payload,\\n                headers=headers,\\n                timeout=10,\\n            )\\n            response.raise_for_status()",
      "line_numbers": "lines 38–55",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "ssrf",
        "opsgenie",
        "env"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "environment"
    },
    {
      "id": "GEN-FP-003",
      "title": "SSRF via Unvalidated Host Configuration",
      "finding_id": "54d982f1-00ba-44ee-a914-42d133e28688",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Operator-controlled environment variable",
      "false_positive_reasoning": "The `KUBO_HOST` value is sourced exclusively from the process environment and configured by the operator/runtime. There is no path for untrusted user input to influence this variable. Using it to construct Kubo URLs does not constitute an application-layer SSRF; exploitation would require prior compromise of deployment/CI configuration which is outside the app threat model.",
      "gap_explanation": "Scanner treated an operator-provided environment variable (`KUBO_HOST`) as attacker-controlled input. The project retrieves it via `os.getenv` and uses it to reach an IPFS Kubo node.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/providers/ipfs/kubo.py",
      "code_snippet": "url = f\"{self.host}:{self.gateway_port}/ipfs/{cid}\"\\nurl = f\"{self.host}:{self.rpc_port}/api/v0/add\"\\nurl = f\"{self.host}:{self.rpc_port}/api/v0/pin/add\"",
      "line_numbers": "multiple locations",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "dev_infra_crypto",
        "ipfs"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "ssrf",
        "ipfs",
        "kubo",
        "env"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "environment"
    },
    {
      "id": "GEN-FP-004",
      "title": "SSRF via Unvalidated Host Parameter",
      "finding_id": "08b8900d-5955-4fb1-a2f8-766ddc75b84a",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Operator-controlled environment variable",
      "false_positive_reasoning": "`LIDO_IPFS_HOST` is provided by operators via process environment and not influenced by end users. The `urljoin(self.host, ...)` usage for fetch requests does not introduce an attacker-controlled URL. Exploitation would require control over deployment configuration, which is outside the application threat model.",
      "gap_explanation": "Scanner assumed `LIDO_IPFS_HOST` could be attacker-controlled. In this project it is solely configured by the operator and used to reach a dedicated Lido IPFS endpoint.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/providers/ipfs/lido_ipfs.py",
      "code_snippet": "url = urljoin(self.host, f\"/ipfs/{cid}\")\\nresp = requests.get(url, headers=self._get_headers(), timeout=self.timeout)",
      "line_numbers": "multiple locations",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "dev_infra_crypto",
        "ipfs"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "ssrf",
        "ipfs",
        "lido-ipfs",
        "fetch",
        "env"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "environment"
    },
    {
      "id": "GEN-FP-005",
      "title": "SSRF via Unvalidated Host Parameter in Upload",
      "finding_id": "a608e714-f1e8-4343-af57-70c9d8f07b4b",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Operator-controlled environment variable",
      "false_positive_reasoning": "As with fetch, `LIDO_IPFS_HOST` is operator-controlled via environment configuration. Upload requests constructed with `urljoin(self.host, \"/add\")` are not attacker-controlled. Exploitation requires control over deployment settings, which is outside the intended threat model.",
      "gap_explanation": "Scanner flagged unvalidated dynamic URL composition without considering the trusted configuration source for `LIDO_IPFS_HOST`.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/providers/ipfs/lido_ipfs.py",
      "code_snippet": "url = urljoin(self.host, \"/add\")\\nresponse = requests.post(\\n    url,\\n    files={\"file\": content},\\n    params=params,\\n    headers=self._get_headers(),\\n    timeout=self.timeout\\n)",
      "line_numbers": "multiple locations",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "dev_infra_crypto",
        "ipfs"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "ssrf",
        "ipfs",
        "lido-ipfs",
        "upload",
        "env"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "environment"
  },
  {
    "id": "GEN-FP-019",
    "title": "Reentrancy risk in VaultHub rebalance/withdraw flows (false positive)",
    "finding_id": "f24c5358-a631-4033-80c6-feeaa535797d",
    "severity_claimed_by_scan": "HIGH",
    "bug_category": "Security",
    "gap_category": "Security",
    "technical_gap": "External calls without reentrancy guard",
    "false_positive_reasoning": "The scanner flags reentrancy risk, but VaultHub calls are to trusted, owner-controlled contracts (StakingVault and Lido). receive() is empty and does not trigger privileged paths. Critical functions are owner-protected and all external calls occur after owner checks.",
    "gap_explanation": "Misinterpretation of reentrancy surface; there is no attacker-controlled entry point to privileged state.",
    "scope_status": "IN_SCOPE",
    "date_added": "2025-11-12",
    "code_path": "Contracts/contracts/0.8.25/vaults/VaultHub.sol",
    "code_snippet": "function _rebalance(address _vault, VaultRecord storage _record, uint256 _shares) internal {\n    uint256 valueToRebalance = _getPooledEthBySharesRoundUp(_shares);\n\n    _decreaseLiability(_vault, _record, _shares);\n    _withdraw(_vault, _record, address(this), valueToRebalance);\n    _rebalanceExternalEtherToInternal(valueToRebalance, _shares);\n\n    _updateBeaconChainDepositsPause(_vault, _record, _vaultConnection(_vault));\n\n    emit VaultRebalanced(_vault, _shares, valueToRebalance);\n}",
    "line_numbers": "lines 1132-1152",
    "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
    "chain": "EVM",
    "language": "Solidity",
    "ecosystem": "Immunefi",
    "contest": "Lido Accounting Oracle v7 Competition",
    "project_profile_tags": [
      "oracle_networks",
      "dev_infra_crypto"
    ],
    "fixable_by_rule": false,
    "custom_rule_matched": false,
    "auditor": "JohnLaw",
    "llm_model": "GPT-5"
  },
  {
    "id": "GEN-FP-020",
    "title": "Confirmation Replay Attack via msg.data Manipulation in OperatorGrid",
    "finding_id": "2ac61e52-cc94-433d-85e5-e675a25f903f",
    "severity_claimed_by_scan": "HIGH",
    "bug_category": "Security",
    "gap_category": "Security",
    "technical_gap": "Stateful confirmations susceptible to replay",
    "false_positive_reasoning": "The confirmation mechanism stores confirmations based on raw msg.data, enabling replay when vault state changes. This is a misclassification if no replay path exists due to state snapshot checks. If there is no snapshot guard, it remains risky.",
    "gap_explanation": "Replay token uses dynamic contract state; needs state snapshot to prevent replay.",
    "scope_status": "IN_SCOPE",
    "date_added": "2025-11-12",
    "code_path": "Contracts/contracts/0.8.25/vaults/OperatorGrid.sol",
    "code_snippet": "function changeTier(address _vault, uint256 _requestedTierId, uint256 _requestedShareLimit) external returns (bool) {\n        // ...\n        // store the caller's confirmation; only proceed if the required number of confirmations is met.\n        if (!_collectAndCheckConfirmations(msg.data, vaultOwner, nodeOperator)) return false;\n        uint256 vaultLiabilityShares = vaultHub.liabilityShares(_vault);\n        // verification of liability shares snapshot should occur here\n        // ...\n    }",
    "line_numbers": "lines 430-460",
    "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
    "chain": "EVM",
    "language": "Solidity",
    "ecosystem": "Immunefi",
    "contest": "Lido Accounting Oracle v7 Competition",
    "project_profile_tags": [
      "oracle_networks",
      "dev_infra_crypto"
    ],
    "fixable_by_rule": false,
    "custom_rule_matched": false,
    "auditor": "JohnLaw",
    "llm_model": "GPT-5"
  },
  {
    "id": "GEN-FP-021",
    "title": "Unbounded loop DoS risk in OracleReportSanityChecker historical data lookup",
    "finding_id": "effab6e9-5b6c-4c4d-a586-c6a6e96dc707",
    "severity_claimed_by_scan": "HIGH",
    "bug_category": "Security",
    "gap_category": "Security",
    "technical_gap": "Unbounded iteration over history",
    "false_positive_reasoning": "The loops in _sumNegativeRebasesNotOlderThan and _exitedValidatorsAtTimestamp traverse reportData backwards without a bound, but in practice the data is looked back over a bounded window; if not, DoS may occur. This FP acknowledges potential DoS in pathological histories but assumes bounded lookback and monotonic timestamps.",
    "gap_explanation": "Potential DoS is mitigated by bounded lookback; if unbounded, replay and gas exhaustion could occur.",
    "scope_status": "IN_SCOPE",
    "date_added": "2025-11-12",
    "code_path": "Contracts/contracts/0.8.9/sanity_checks/OracleReportSanityChecker.sol",
    "code_snippet": "function _sumNegativeRebasesNotOlderThan(uint256 _timestamp) internal view returns (uint256) {\n    uint256 sum;\n    for (int256 index = int256(reportData.length) - 1; index >= 0; index--) {\n        if (reportData[uint256(index)].timestamp > SafeCast.toUint64(_timestamp)) {\n            sum += reportData[uint256(index)].negativeCLRebaseWei;\n        } else {\n            break;\n        }\n    }\n    return sum;\n}",
    "line_numbers": "647-657",
    "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
    "chain": "EVM",
    "language": "Solidity",
    "ecosystem": "Immunefi",
    "contest": "Lido Accounting Oracle v7 Competition",
    "project_profile_tags": [
      "oracle_networks",
      "dev_infra_crypto"
    ],
    "fixable_by_rule": false,
    "custom_rule_matched": false,
    "auditor": "JohnLaw",
    "llm_model": "GPT-5"
  }
  ,
  {
    "id": "GEN-FP-024",
    "title": "Quarantine state transition early release in LazyOracle",
    "finding_id": "b2dca4c7-ad14-4fe3-8e44-7096d25729e7",
    "severity_claimed_by_scan": "HIGH",
    "bug_category": "Security",
    "gap_category": "Security",
    "technical_gap": "Quarantine early release bypass",
    "false_positive_reasoning": "The reported bypass relies on a shorter-than-expected quarantine period being released due to threshold, but actual behavior requires the quarantine to be released only when conditions; The patch path.",
    "gap_explanation": "Edge-case in state machine; early release is not intended.",
    "scope_status": "IN_SCOPE",
    "date_added": "2025-11-12",
    "code_path": "Contracts/contracts/0.8.25/vaults/LazyOracle.sol",
    "code_snippet": "function _processTotalValue(address _vault) internal returns (uint256) {\n    // ...\n    if (quarantineActive && _reportedTotalValue <= quarantineThreshold) {\n        delete $.vaultQuarantines[_vault];\n        emit QuarantineReleased(_vault, 0);\n        return _reportedTotalValue;\n    }\n    // ...\n}",
    "line_numbers": "553-567",
    "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
    "chain": "EVM",
    "language": "Solidity",
    "ecosystem": "Immunefi",
    "contest": "Lido Accounting Oracle v7 Competition",
    "project_profile_tags": [
      "oracle_networks",
      "dev_infra_crypto"
    ],
    "fixable_by_rule": false,
    "custom_rule_matched": false,
    "auditor": "JohnLaw",
    "llm_model": "GPT-5"
  },
  {
    "id": "GEN-FP-025",
    "title": "Unsafe quarantine expiration check uses report timestamp",
    "finding_id": "b462b953-0a64-4ef9-a449-6a2aa00c2e92",
    "severity_claimed_by_scan": "MEDIUM",
    "bug_category": "Security",
    "gap_category": "Security",
    "technical_gap": "Quarantine expiration uses report timestamp",
    "false_positive_reasoning": "The scanner flags oracle-driven timestamp use; however the code path uses the on-chain startTimestamp and quarantinePeriod and block.timestamp; the described vulnerability relies on incorrect usage. This is a safety hardening suggestion rather than an immediate exploitable vulnerability.",
    "gap_explanation": "Oracle-driven timestamp usage for real-time expiry; not a proven vulnerability due to existing on-chain time gating.",
    "scope_status": "IN_SCOPE",
    "date_added": "2025-11-12",
    "code_path": "Contracts/contracts/0.8.25/vaults/LazyOracle.sol",
    "code_snippet": "function _determineQuarantineState(...) internal view returns (QuarantineState) {\n    // ...\n    bool isQuarantineExpired = (block.timestamp - _quarantine.startTimestamp) >= _storage().quarantinePeriod;\n    // ...\n}",
    "line_numbers": "601-606",
    "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
    "chain": "EVM",
    "language": "Solidity",
    "ecosystem": "Immunefi",
    "contest": "Lido Accounting Oracle v7 Competition",
    "project_profile_tags": [
      "oracle_networks",
      "dev_infra_crypto"
    ],
    "fixable_by_rule": false,
    "custom_rule_matched": false,
    "auditor": "JohnLaw",
    "llm_model": "GPT-5"
  }
    ,
    {
      "id": "GEN-FP-006",
      "title": "Arbitrary Code Execution via pytest Configuration and Test Files",
      "finding_id": "95e4a152-dbcc-4265-bbe6-ef19bed60f08",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Operator-controlled test files",
      "false_positive_reasoning": "The ChecksModule invokes pytest to run tests from `src/modules/checks/suites` using an operator-provided pytest configuration. The pytest hooks (e.g., `conftest.py`) execute in the same process, so a malicious test or modified pytest.ini could execute arbitrary code. However, the ability to modify repository test files or the runtime pytest.ini is an operator/deployment-level capability; there is no untrusted external input path in the application that allows arbitrary actors to change those files. Exploitation requires prior compromise of repository/CI/deployment where tests live, which is outside the application's threat model.",
      "gap_explanation": "Scanner treated test-suite files and pytest config as attacker-controlled inputs. In normal deployments these files are controlled by operators/maintainers; mitigating arbitrary modification is an infrastructure/ops concern (file permissions, CI protections), not an application-level SSRF/RCE vulnerability.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/modules/checks/checks_module.py",
      "code_snippet": "    def execute_module(self):\\n        return pytest.main([\\n            'src/modules/checks/suites',\\n            '-c', 'src/modules/checks/pytest.ini',\\n        ])",
      "line_numbers": "lines 18–22",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "dev_infra_crypto",
        "oracle_networks"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "rce",
        "pytest",
        "test-runner"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "file/snapshot"
    }
    ,
    {
      "id": "GEN-FP-007",
      "title": "Path Traversal Vulnerability in File Reading Function",
      "finding_id": "df185abe-3abb-4b19-8102-2a2007c19112",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Operator-controlled env var",
      "false_positive_reasoning": "The `from_file_or_env` helper reads a file path from `${ENV_NAME}_FILE` and returns its contents. While the implementation does not restrict directory traversal, the file path is provided via an environment variable which is controlled by operators at deployment time. There is no application-level untrusted input that can arbitrarily set these environment values. Exploitation would require control over the process environment or deployment configuration (CI/host), which is out of scope for application-layer security analysis.",
      "gap_explanation": "Scanner assumed environment-derived file paths are attacker-controlled. In practice these values are set by deployment/ops; preventing malicious file paths is an infrastructure responsibility (e.g., secret mounts, file permissions) rather than an application logic bug in this codebase.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/utils/env.py",
      "code_snippet": "def from_file_or_env(env_name: str):\\n    \"\"\"Return value read from `${env_name}_FILE` or `${env_name}` value directly\"\"\"\\n\\n    filepath_env = f\"{env_name}_FILE\"\\n    if filepath := os.getenv(filepath_env):\\n        if not os.path.exists(filepath):\\n            raise ValueError(f'File {filepath} does not exist. Fix {filepath_env} variable or remove it.')\\n\\n        with open(filepath) as f:\\n            return f.read().rstrip()",
      "line_numbers": "lines 4–15",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "path-traversal",
        "secrets",
        "env"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "environment"
    }
    ,
    {
      "id": "GEN-FP-008",
      "title": "JWT Token Signature Not Verified (Pinata usage)",
      "finding_id": "43c338f9-fb64-4738-89da-ae27534554ad",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Structural-only JWT check",
      "false_positive_reasoning": "The Pinata provider calls `validate_jwt(jwt_token)` on construction which explicitly validates only the JWT structure. This function is a convenience to ensure formatting before setting the Authorization header; actual authentication and signature verification are performed by the remote Pinata service. The structural check prevents malformed tokens from being set but does not attempt client-side cryptographic verification, which is an operational design decision rather than a standalone authentication bypass in this client code.",
      "gap_explanation": "Scanner interpreted the structural check as missing cryptographic verification in the client. In practice the Pinata API enforces signature verification server-side; the client-side function only guards against malformed input and is not relied upon for security decisions within the application.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/providers/ipfs/pinata.py",
      "code_snippet": "    def __init__(self, jwt_token: str, *, timeout: int, dedicated_gateway_url: str, dedicated_gateway_token: str) -> None:\\n        super().__init__()\\n        validate_jwt(jwt_token)\\n        self.timeout = timeout\\n\\n        self.session = requests.Session()\\n        self.session.headers[\"Authorization\"] = f\"Bearer {jwt_token}\"",
      "line_numbers": "lines 24–31",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "dev_infra_crypto",
        "oracle_networks"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "jwt",
        "pinata",
        "auth"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "environment"
    }
    ,
    {
      "id": "GEN-FP-009",
      "title": "JWT Signature Not Verified - base64 decode usage",
      "finding_id": "0e5b18ac-636a-44f6-9545-b6b0e61fa158",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Base64 structural validation",
      "false_positive_reasoning": "The `decode_base64url` helper correctly implements base64url decoding and is used by `validate_jwt` to parse JWT header and payload. It raises on invalid input and does not attempt signature verification. The helper's role is decoding; cryptographic verification is out of scope and is expected to be performed by the authentication authority (Pinata) or a separate verification function.",
      "gap_explanation": "Scanner flagged base64 decoding as enabling JWT forgery. Decoding is a necessary parsing step; absence of signature checking in this helper is intentional and not a standalone vulnerability in the decoding routine.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/utils/base64.py",
      "code_snippet": "def decode_base64url(data: str) -> str:\\n    # Replace base64url specific characters back to standard base64.\\n    data = data.replace(\"-\", \"+\").replace(\"_\", \"/\")\\n    # Calculate and add necessary padding (expected by b64decode).\\n    padding = \"=\" * ((4 - len(data) % 4) % 4)\\n    data += padding\\n    try:\\n        return base64.b64decode(data).decode(\"utf-8\")",
      "line_numbers": "lines 5–17",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "base64",
        "jwt",
        "parsing"
      ],
      "patterns": [
        "language-model-mismatch"
      ],
      "taint_source": "internal"
    }
    ,
    {
      "id": "GEN-FP-010",
      "title": "JWT Signature Not Verified - validate_jwt structural check",
      "finding_id": "e7b1d3b3-d309-4cf1-a02f-5e9315c964c7",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Structure-only validation",
      "false_positive_reasoning": "The `validate_jwt` function explicitly documents that it validates JWT structure without verifying the signature. It enforces token formatting (three parts, base64url-decodable JSON header and payload) and raises on malformed tokens. The application does not rely on this function for cryptographic trust decisions; it is a parsing guard. Full signature verification is the responsibility of the authentication provider or should be performed by a dedicated verification function.",
      "gap_explanation": "Scanner treated structural validation as a missing cryptographic verification step. The function's docstring and implementation make its scope explicit; flagging it as a standalone cryptographic verification bug misses the design intent and operational context.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/utils/jwt.py",
      "code_snippet": "def validate_jwt(token: Any):\\n    \"\"\"Validates a JWT token's structure without verifying the signature\"\"\"\\n\\n    if not isinstance(token, str):\\n        raise ValueError(\"Invalid JWT: Token must be a string\")\\n\\n    parts = token.split(\".\")\\n    if len(parts) != 3:\\n        raise ValueError(\"Invalid JWT format: Token must have 3 parts separated by dots\")",
      "line_numbers": "lines 7–16",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "jwt",
        "validation",
        "auth"
      ],
      "patterns": [
        "language-model-mismatch"
      ],
      "taint_source": "internal"
    }
    ,
    {
      "id": "GEN-FP-011",
      "title": "Sensitive Private Key Exposed in PRIVATE_ENV_VARS Dictionary",
      "finding_id": "ceadccf0-c7c5-4736-bd54-93a4ac77fbee",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Secrets stored in dict",
      "false_positive_reasoning": "The PRIVATE_ENV_VARS mapping does include `MEMBER_PRIV_KEY` as one of many private configuration values. This dictionary is populated from environment variables during process startup and is intended for internal bookkeeping of which variables are considered private (used to prevent accidental public logging). The codebase does not serialize or log the contents of PRIVATE_ENV_VARS in normal operation; `PUBLIC_ENV_VARS` is used for safe public logging. The private key value remains in memory as the MEMBER_PRIV_KEY variable (necessary for cryptographic operations) but is not written to logs or external outputs by default.",
      "gap_explanation": "Scanner flagged presence of secrets in an in-memory dict without tracing actual exposures. The project treats these variables as private (keeps them in PRIVATE_ENV_VARS) and uses `PUBLIC_ENV_VARS` for public logs. Preventing accidental leak is an ops/configuration concern (secret mounts, least-privilege) rather than an application-level bug in this initial mapping.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/variables.py",
      "code_snippet": "PRIVATE_ENV_VARS = {\\n    'EXECUTION_CLIENT_URI': EXECUTION_CLIENT_URI,\\n    'CONSENSUS_CLIENT_URI': CONSENSUS_CLIENT_URI,\\n    'KEYS_API_URI': KEYS_API_URI,\\n    'PINATA_JWT': PINATA_JWT,\\n    'STORACHA_AUTH_SECRET': STORACHA_AUTH_SECRET,\\n    'STORACHA_AUTHORIZATION': STORACHA_AUTHORIZATION,\\n    'STORACHA_SPACE_DID': STORACHA_SPACE_DID,\\n    'LIDO_IPFS_HOST': LIDO_IPFS_HOST,\\n    'LIDO_IPFS_TOKEN': LIDO_IPFS_TOKEN,\\n    'PINATA_DEDICATED_GATEWAY_TOKEN': PINATA_DEDICATED_GATEWAY_TOKEN,\\n    'MEMBER_PRIV_KEY': MEMBER_PRIV_KEY,\\n    'OPSGENIE_API_KEY': OPSGENIE_API_KEY,\\n    'OPSGENIE_API_URL': OPSGENIE_API_URL,\\n}",
      "line_numbers": "lines 170–184",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "dev_infra_crypto",
        "oracle_networks"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "secrets",
        "env",
        "privkey"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "environment"
    }
    ,
    {
      "id": "GEN-FP-012",
      "title": "Path Traversal Vulnerability in from_file_or_env",
      "finding_id": "eba2c87e-163e-4b3d-b6ea-3a50e3c4bbfc",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Env-file path unchecked",
      "false_positive_reasoning": "The helper `from_file_or_env` reads `${ENV_NAME}_FILE` if set and returns file contents. While it does not canonicalize or restrict paths, the environment variables that control these file paths are set by operators at deployment time. There is no code path within the application that allows untrusted remote actors to set these environment variables; therefore exploitation requires control over the deployment environment (CI/host), which falls outside the application threat model.",
      "gap_explanation": "Scanner flagged potential path traversal without acknowledging that `${ENV_NAME}_FILE` is operator-controlled configuration. Preventing malicious file mounts or ensuring secret volumes are used is an infrastructure/ops responsibility, not an application-layer vulnerability in this parsing helper.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/utils/env.py",
      "code_snippet": "def from_file_or_env(env_name: str):\\n    filepath_env = f\"{env_name}_FILE\"\\n    if filepath := os.getenv(filepath_env):\\n        if not os.path.exists(filepath):\\n            raise ValueError(f'File {filepath} does not exist. Fix {filepath_env} variable or remove it.')\\n\\n        with open(filepath) as f:\\n            return f.read().rstrip()",
      "line_numbers": "lines 4–15",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "path-traversal",
        "env",
        "secrets"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "environment"
    }
    ,
    {
      "id": "GEN-FP-013",
      "title": "Hardcoded All-Zero GENESIS_VALIDATORS_ROOT (testing placeholder)",
      "finding_id": "e27c5774-1cf8-4019-8a54-9c06bad9e0dd",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Testnet placeholder constant",
      "false_positive_reasoning": "The constant `GENESIS_VALIDATORS_ROOT = bytes([0] * 32)` is present in `src/constants.py` with a comment indicating it's used 'for deposits'. This repository contains many test and local-run utilities; the placeholder all-zero root is commonly used for non-production/test setups. There is no evidence in the code that this value is used for production signing or that it is applied to live network deposits without operator configuration.",
      "gap_explanation": "Scanner flagged a cryptographic constant but did not distinguish test/development defaults from production configuration. Operators must supply correct network parameters for production; the codebase uses this placeholder for testing convenience and should be overridden in real deployments.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/constants.py",
      "code_snippet": "GENESIS_VALIDATORS_ROOT = bytes([0] * 32)  # all zeros for deposits",
      "line_numbers": "line 1",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "staking_liquid_staking",
        "execution_layer"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "constants",
        "genesis",
        "placeholder"
      ],
      "patterns": [
        "trusted-config"
      ],
      "taint_source": "internal"
    }
    ,
    {
      "id": "GEN-FP-014",
      "title": "Insufficient CID Validation in is_cid_v0 Function",
      "finding_id": "799c60da-046d-443e-936e-7ed901f92f7d",
      "severity_claimed_by_scan": "MEDIUM",
      "bug_category": "Security",
      "gap_category": "Logic/Correctness",
      "technical_gap": "Heuristic type check only",
      "false_positive_reasoning": "The `is_cid_v0` helper performs a lightweight heuristic (prefix 'Qm' and length 46) used solely to choose between `CIDv0` and `CIDv1` wrapper classes when reading CIDs returned by trusted contracts. It is not a security boundary. CIDs are then interpolated into provider URLs under a fixed `/ipfs/{cid}` path, which prevents path traversal. Invalid or malformed strings lead to bounded request failures (timeouts and limited retries) and raise `FetchError`, without enabling SSRF or privilege escalation. For content integrity, the codebase uses multiformats-based CID normalization and optional content validation (`IPFS_VALIDATE_CID`) for upload/publish flows; fetching untrusted CIDs does not rely on `is_cid_v0` for security decisions.",
      "gap_explanation": "Scanner conflated a convenience classifier with security validation. The application treats CID classification as non-authoritative; network usage is path-scoped and guarded by timeouts/retries, and integrity checks exist where relevant. Weakness here does not create an external attacker-controlled exploit path.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/providers/ipfs/cid.py",
      "code_snippet": "def is_cid_v0(cid: str) -> bool:\\n    return cid.startswith(\"Qm\") and len(cid) == 46",
      "line_numbers": "lines 18–19",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Other",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "dev_infra_crypto",
        "ipfs"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "cid",
        "ipfs",
        "validation"
      ],
      "patterns": [
        "validation-heuristic"
      ],
      "taint_source": "internal"
    }
  ,
    {
      "id": "GEN-FP-015",
      "title": "Missing Input Validation in CID Class Constructors",
      "finding_id": "044de24e-f317-4ca1-8b0d-dffde7de8bb1",
      "severity_claimed_by_scan": "MEDIUM",
      "bug_category": "Security",
      "gap_category": "Code Quality",
      "technical_gap": "CID classes lack constructor validation; providers enforce multiformats-based validation and content-hash checks by default.",
      "false_positive_reasoning": "By default the system normalizes/validates CIDs using multiformats on fetch/publish and verifies content hashes when IPFS_VALIDATE_CID is True (default). CID inputs come from trusted on-chain sources or internal flows; there is no attacker-controlled path to inject arbitrary absolute URLs. The only provider that could accept absolute URLs (Storacha) would require an attacker to control the CID value, which is not possible under the current architecture. Invalid CIDs lead to bounded request errors, not exploitation.",
      "gap_explanation": "Scanner treated the lack of constructor validation as a security boundary failure. In practice, invariants are enforced at provider boundaries (decode/normalize and optional content validation), URLs are path-scoped, and CID sources are trusted. This is a defense-in-depth/code quality concern rather than an exploitable vulnerability.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "src/providers/ipfs/cid.py",
      "code_snippet": "class CID(UserString):\\n    def __repr__(self):\\n        return f\\\"{self.__class__.__name__}({self.data})\\\"\\n\\n\\nclass CIDv0(CID):\\n    ...\\n\\n\\nclass CIDv1(CID):\\n    ...",
      "line_numbers": "lines 4–14",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "Other",
      "language": "Python",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "dev_infra_crypto",
        "ipfs"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "cid",
        "ipfs",
        "validation",
        "defense-in-depth"
      ],
      "patterns": [
        "validation-at-boundaries"
      ],
      "taint_source": "internal"
    },
    {
      "id": "GEN-FP-018",
      "title": "Reentrancy via connectToVaultHub in createVaultWithDashboard is not possible",
      "finding_id": "e0f95501-2159-477e-ac5d-9a78ee34032c",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Payable call bypasses receive",
      "false_positive_reasoning": "The alleged reentrancy relies on Dashboard.receive() being triggered when the factory calls dashboard.connectToVaultHub{value: msg.value}(). In Solidity, calling a payable function with value invokes that function directly, not the receive() handler. The called function (connectToVaultHub) only funds the vault, transfers vault ownership to VaultHub, and calls VaultHub.connectVault; it does not invoke attacker-controlled external code. Any privileged Dashboard methods require onlyRole(DEFAULT_ADMIN_ROLE), and during the sequence the msg.sender is the factory itself. There is no callback path for an attacker to execute admin-gated operations before the role is revoked.",
      "gap_explanation": "Misunderstood payable/receive dispatch and role-gated authorization; assumed external callback into admin-only functions during a single transaction without a callable entry point.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "Contracts/contracts/0.8.25/vaults/VaultFactory.sol",
      "code_snippet": "        // initialize Dashboard with the factory address as the default admin, grant optional roles and connect to VaultHub\\n        dashboard.initialize(address(this), _nodeOperatorManager, _nodeOperatorManager, _nodeOperatorFeeBP, _confirmExpiry);\\n\\n        dashboard.connectToVaultHub{value: msg.value}();\\n\\n        if (_roleAssignments.length > 0) dashboard.grantRoles(_roleAssignments);\\n\\n        dashboard.grantRole(dashboard.DEFAULT_ADMIN_ROLE(), _defaultAdmin);\\n        dashboard.revokeRole(dashboard.DEFAULT_ADMIN_ROLE(), address(this));\\n\\n        emit VaultCreated(address(vault));",
      "line_numbers": "lines 99–109",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "EVM",
      "language": "Solidity",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "staking_liquid_staking",
        "execution_layer"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "reentrancy",
        "access-control",
        "payable-dispatch"
      ],
      "patterns": [
        "auth-capability-upstream",
        "language-model-mismatch"
      ],
      "guard_kind": "RUNTIME_INVARIANT",
      "guard_symbol": "payable function dispatch (no receive())",
      "taint_source": "rpc",
      "num_hops": 0
    },
    {
      "id": "GEN-FP-021",
      "title": "Second opinion oracle zeroing does not bypass CL balance decrease check",
      "finding_id": "2569e841-ddcf-4019-99ad-95c64d27d768",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Admin can zero oracle",
      "false_positive_reasoning": "The scanner assumed that setting `secondOpinionOracle` to the zero address disables the second-opinion check and allows oversized negative CL rebases to be accepted. In reality `_checkCLBalanceDecrease` explicitly reverts when an over-limit negative CL rebase is detected and `secondOpinionOracle` is the zero address. The code therefore fails-safe (reverts) rather than accepting unsafe reports when the oracle is disabled.",
      "gap_explanation": "Misread of control flow: disabling the oracle triggers a revert path on over-limit negative CL rebases, not an acceptance path. The safety check requires a successful second opinion to proceed when limits are exceeded.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "Contracts/contracts/0.8.9/sanity_checks/OracleReportSanityChecker.sol",
      "code_snippet": "function setSecondOpinionOracleAndCLBalanceUpperMargin(ISecondOpinionOracle _secondOpinionOracle, uint256 _clBalanceOraclesErrorUpperBPLimit)\n    external\n    onlyRole(SECOND_OPINION_MANAGER_ROLE)\n{\n    LimitsList memory limitsList = _limits.unpack();\n    limitsList.clBalanceOraclesErrorUpperBPLimit = _clBalanceOraclesErrorUpperBPLimit;\n    _updateLimits(limitsList);\n    if (_secondOpinionOracle != secondOpinionOracle) {\n        secondOpinionOracle = ISecondOpinionOracle(_secondOpinionOracle);\n        emit SecondOpinionOracleChanged(_secondOpinionOracle);\n    }",
      "line_numbers": "lines 372–386",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "EVM",
      "language": "Solidity",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "staking_liquid_staking"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "oracle",
        "second-opinion",
        "safety-check"
      ],
      "patterns": [
        "trusted-peer-scope"
      ],
      "taint_source": "internal"
    },
    {
      "id": "GEN-FP-022",
      "title": "Unsafe downcasting in LazyOracle quarantine storage (false positive)",
      "finding_id": "a98e0491-0cc9-44c6-8e4d-e60023f78b5a",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Unchecked downcast to uint128/uint64",
      "false_positive_reasoning": "The scanner flagged silent truncation on downcasts in `_startNewQuarantine` and when updating `totalValueRemainder`. While downcasting without explicit checks is generally risky, reported total values are bounded earlier (see MAX_SANE_TOTAL_VALUE) and quarantined amounts derive from reported values constrained by protocol limits. Exploitation requires feeding numeric values beyond protocol sanity checks which are unlikely in practice. Recommend SafeCast adoption as defensive hardening.",
      "gap_explanation": "Static pattern matched downcasts without accounting for upstream guards and protocol-level sanity constraints that limit reported values. This is a code-quality hardening suggestion rather than an immediate exploitable vulnerability.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "Contracts/contracts/0.8.25/vaults/LazyOracle.sol",
      "code_snippet": "function _startNewQuarantine(\\n        Quarantine storage _quarantine,\\n        uint256 _amountToQuarantine,\\n        uint256 _currentTimestamp\\n    ) internal {\\n        _quarantine.pendingTotalValueIncrease = uint128(_amountToQuarantine);\\n        _quarantine.startTimestamp = uint64(_currentTimestamp);\\n        _quarantine.totalValueRemainder = 0;\\n    }",
      "line_numbers": "lines 605–613",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "EVM",
      "language": "Solidity",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "staking_liquid_staking",
        "oracle_networks"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "integer-downcast",
        "quarantine",
        "defense-in-depth"
      ],
      "patterns": [
        "validation-at-boundaries"
      ],
      "taint_source": "internal"
    },
    {
      "id": "GEN-FP-023",
      "title": "Unsafe downcasting in LazyOracle.updateReportData is not exploitable under sanity guards",
      "finding_id": "e18b4074-4fba-40d4-96eb-6232ade7a678",
      "severity_claimed_by_scan": "HIGH",
      "bug_category": "Security",
      "gap_category": "Security",
      "technical_gap": "Unchecked downcast to uint64/uint48",
      "false_positive_reasoning": "The scanner flagged the downcasts in `updateReportData` for potential silent truncation. However, the function is restricted to calls from the AccountingOracle (enforced via `msg.sender` check) which supplies bounded inputs derived from on-chain sources. Protocol invariants constrain refSlot and timestamp ranges. While SafeCast would be a defensive improvement, this report is a low-risk false positive.",
      "gap_explanation": "Static matching of downcasts omitted caller trust assumptions and existing protocol bounds; treat as a code-quality suggestion.",
      "scope_status": "IN_SCOPE",
      "date_added": "2025-11-12",
      "code_path": "Contracts/contracts/0.8.25/vaults/LazyOracle.sol",
      "code_snippet": "function updateReportData(\\n        uint256 _vaultsDataTimestamp,\\n        uint256 _vaultsDataRefSlot,\\n        bytes32 _vaultsDataTreeRoot,\\n        string memory _vaultsDataReportCid\\n    ) external override(ILazyOracle) {\\n        if (msg.sender != LIDO_LOCATOR.accountingOracle()) revert NotAuthorized();\\n\\n        Storage storage $ = _storage();\\n        $.vaultsDataTimestamp = uint64(_vaultsDataTimestamp);\\n        $.vaultsDataRefSlot = uint48(_vaultsDataRefSlot);\\n        $.vaultsDataTreeRoot = _vaultsDataTreeRoot;\\n        $.vaultsDataReportCid = _vaultsDataReportCid;\\n    }",
      "line_numbers": "lines 300–313",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
      "chain": "EVM",
      "language": "Solidity",
      "ecosystem": "Immunefi",
      "contest": "Lido Accounting Oracle v7 Competition",
      "project_profile_tags": [
        "oracle_networks",
        "dev_infra_crypto"
      ],
      "fixable_by_rule": false,
      "custom_rule_matched": false,
      "auditor": "JohnLaw",
      "llm_model": "GPT-5",
      "tags": [
        "integer-downcast",
        "trusted-caller"
      ],
      "patterns": [
        "trusted-peer-scope",
        "validation-at-boundaries"
      ],
      "taint_source": "internal"
    }
  ,
  {
    "id": "GEN-FP-026",
    "title": "Excess ETH handling in VaultFactory create-flow",
    "finding_id": "19015fe6-a498-438a-96cb-d504cf05583e",
    "severity_claimed_by_scan": "MEDIUM",
    "bug_category": "Security",
    "gap_category": "Logic/Correctness",
    "technical_gap": "Misread gas/value flow: ETH is forwarded to StakingVault via Dashboard, not to VaultHub",
    "false_positive_reasoning": "ETH sent to createVaultWithDashboard is forwarded to the StakingVault via Dashboard.connectToVaultHub (which calls _stakingVault().fund{value: msg.value}()), not to VaultHub. VaultHub.connectVault is non-payable and only checks the vault’s balance being ≥ CONNECT_DEPOSIT; it does not receive or retain msg.value. Any ‘excess’ ETH becomes part of the vault’s balance, increasing capacity, and can be withdrawn via Dashboard.withdraw (role-gated WITHDRAW_ROLE under DEFAULT_ADMIN_ROLE). Therefore no ETH is permanently locked in VaultHub.",
    "gap_explanation": "The report assumed msg.value was sent to VaultHub and became unrecoverable. In reality the value funds the vault and remains governed by Dashboard permissions. Optional UX could enforce exactly 1 ETH, but there is no security issue.",
    "scope_status": "IN_SCOPE",
    "date_added": "2025-11-12",
    "code_path": "Contracts/contracts/0.8.25/vaults/VaultFactory.sol",
    "code_snippet": "dashboard.connectToVaultHub{value: msg.value}();",
    "line_numbers": "lines 102-102",
      "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
    "chain": "EVM",
    "language": "Solidity",
    "ecosystem": "Immunefi",
    "contest": "Lido Accounting Oracle v7 Competition",
    "project_profile_tags": [
      "staking_liquid_staking",
      "dev_infra_crypto"
    ],
    "fixable_by_rule": false,
    "custom_rule_matched": false,
    "auditor": "JohnLaw",
    "llm_model": "GPT-5",
    "tags": [
      "security",
      "ether",
      "refund",
      "vault",
      "factory"
    ],
    "patterns": [
      "excess-eth",
      "refund-path",
      "vault-flow"
    ],
    "taint_source": "internal"
  }
  ,
  {
    "id": "GEN-FP-027",
    "title": "Reentrancy false positive in PredepositGuarantee.withdrawNodeOperatorBalance",
    "finding_id": "4c2f697e-1d37-46c4-a0e6-32ac6aa4fa08",
    "severity_claimed_by_scan": "MEDIUM",
    "bug_category": "Security",
    "gap_category": "Security",
    "technical_gap": "External ETH transfer without explicit reentrancy guard flagged by heuristic",
    "false_positive_reasoning": "False Positive - The function follows the Checks-Effects-Interactions (CEI) pattern: it decreases the accounting balance before performing the external ETH transfer. The simplified sequence is `balance.total -= uint128(_amount); (bool success, ) = _recipient.call{value: _amount}(\"\"); if (!success) revert WithdrawalFailed();`. Because the accounting reduction happens prior to the external call and the function does not perform any subsequent state writes that depend on pre-call values, a reentrant recipient cannot increase its effective withdrawable amount or corrupt accounting. The only thing a malicious recipient can do is revert, which reverts the whole transaction and restores the deducted balance. No exploit path to extract additional funds was found.",
    "gap_explanation": "Automated heuristics flagged any external call without a reentrancy guard. Here CEI is correctly applied and there are no post-interaction state updates that an attacker could exploit. A reentrant callback cannot observe a stale higher balance because balance was already decremented. Adding a nonReentrant guard is optional defensive hardening but not required for correctness in this case.",
    "scope_status": "IN_SCOPE",
    "date_added": "2025-11-12",
    "code_path": "Contracts/contracts/0.8.25/vaults/predeposit_guarantee/PredepositGuarantee.sol",
    "code_snippet": "balance.total -= uint128(_amount);\n(bool success, ) = _recipient.call{value: _amount}(\"\");\nif (!success) revert WithdrawalFailed();",
    "line_numbers": "N/A",
    "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
    "chain": "EVM",
    "language": "Solidity",
    "ecosystem": "Immunefi",
    "contest": "Lido Accounting Oracle v7 Competition",
    "project_profile_tags": [
      "staking_liquid_staking",
      "dev_infra_crypto"
    ],
    "fixable_by_rule": false,
    "custom_rule_matched": false,
    "auditor": "JohnLaw",
    "llm_model": "GPT-5",
    "tags": [
      "reentrancy",
      "checks-effects-interactions",
      "predeposit-guarantee",
      "withdrawal",
      "false_positive"
    ],
    "patterns": [
      "reentrancy-heuristic",
      "cei"
    ],
    "taint_source": "internal"
  },
  {
    "id": "GEN-FP-028",
    "title": "preservesEthBalance assert in WithdrawalVault flagged as DoS (false positive)",
    "finding_id": "d91d657a-0a28-41ed-95b0-6bfe7aba5769",
    "severity_claimed_by_scan": "MEDIUM",
    "bug_category": "Security",
    "gap_category": "Security",
    "technical_gap": "Invariant assert on ETH balance flagged as DoS risk",
    "false_positive_reasoning": "False Positive - The `preservesEthBalance` modifier encodes an invariant that the function must not net-retain ETH after accounting for `msg.value`. Unexpected ETH arrival during a protected call requires an attacker-controlled in-tx transfer (e.g., via a reentrant callback or selfdestruct from code executed during the same transaction). The reported `addWithdrawalRequests` path contains no attacker-controlled external callback that could inject ETH before the trailing `assert`. Therefore the assertion holds in practice and does not present a viable DoS vector.",
    "gap_explanation": "Rule-based scanners flag post-call balance assertions as potential DoS when they see ETH comparisons. The scanner assumed unsolicited in-tx ETH injection is possible; but without a demonstrated attacker-controlled callback into the vault during the protected execution, the scenario is theoretical. Using `assert` for this invariant is acceptable; converting to `require` is optional operational hardening.",
    "scope_status": "IN_SCOPE",
    "date_added": "2025-11-12",
    "code_path": "Contracts/contracts/0.8.9/WithdrawalVault.sol",
    "code_snippet": "modifier preservesEthBalance() {\n    uint256 balanceBeforeCall = address(this).balance - msg.value;\n    _;\n    assert(address(this).balance == balanceBeforeCall);\n}",
    "line_numbers": "N/A",
    "commit_hash": "d6c09a16736b2c132343a4e349c8f27179c73e6e",
    "chain": "EVM",
    "language": "Solidity",
    "ecosystem": "Immunefi",
    "contest": "Lido Accounting Oracle v7 Competition",
    "project_profile_tags": [
      "execution_layer",
      "staking_liquid_staking",
      "dev_infra_crypto"
    ],
    "fixable_by_rule": false,
    "custom_rule_matched": false,
    "auditor": "JohnLaw",
    "llm_model": "GPT-5",
    "tags": [
      "dos",
      "assert",
      "withdrawal-vault",
      "eip-7002"
    ],
    "patterns": [
      "balance-invariant",
      "assert-used"
    ],
    "taint_source": "internal"
  }
  ]
}

