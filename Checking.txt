Here’s a fast, auditor-oriented map of the most likely hotspots in core v3.0.0-rc.4, pulled straight from the release + linked PRs. I also note what to try first (tests/PoCs) for each.

1) VaultHub: fees + unhealthy vault handling

Why hot: The release explicitly calls out “Apply fees on unhealthy vault in VaultHub” and a “Shortfall strikes back” change—both touch accounting branches that are easy to get subtly wrong (fee application order, rounding, and state transitions when a vault is unhealthy / under water). Coverage report shows large, uncovered regions in VaultHub.sol (e.g., 586–679, 1498–1508), which likely includes these code paths.

Try first:

Construct a vault that flips from healthy→unhealthy mid-epoch and assert fee math doesn’t extract value when badDebt > 0.

Fuzz sequencing of: report updates → fee accrual → shortfall absorption → vault exits.

Invariants: “user assets + protocol fees + badDebtToInternalize” conservation; no fee on negative performance; monotone debt internalization.

Watch for off-by-one and rounding in per-share math.

GitHub

2) “Shortfall strikes back” rework (accounting edges)

Why hot: PR title suggests a regression fix or a re-activation of shortfall logic. These patches often re-wire ordering between loss realization, fee gating, and state flags.

Try first:

Differential test between pre-/post-PR behavior under small losses with fees > 0.

Force rapid loss/gain oscillations across the unhealthy threshold and assert final supply/balances are consistent.

GitHub

3) badDebtToInternalize flow (Accounting ←→ VaultHub integration)

Why hot: New/changed variable is directly in the settlement path; mis-ordering can mint/burn the wrong side or leak value.

Try first:

Simulate partial internalization across multiple reports: ensure debt doesn’t “revive” after being counted; assert sum(share value) + badDebt monotonically reconciles.

Fuzz tiny debt amounts to look for truncation that either strands dust or flips sign.

GitHub

4) LazyOracle batch getters (freshly added surface)

Why hot: Batch accessors often bypass the single-call guards/assumptions; they can leak stale or cross-mixed state that callers misinterpret. Coverage shows some uncovered lines in LazyOracle.sol.

Try first:

Feed mixed validator sets (different stages/status) and assert outputs remain index-aligned and bounded.

Time-skew tests around report boundaries; assert no inconsistent pairs (status A from T, status B from T+1).

GitHub

5) Operator/NOR changes — “remove transfer to vault”

Why hot: Removing transferToVault changes custody/flow assumptions. If anything else still assumes that path exists, it can create stuck funds or missing accounting. PR references a post-mortem (NOR operations are historically delicate).

Try first:

Trace any remaining code paths that expect a “push” transfer; attempt deposits/withdrawals around the removed path and assert no stranded balances.

Verify permissions didn’t accidentally broaden with the refactor.

GitHub

6) StakingVault edge branches (87% coverage; gaps at lines 307–341)

Why hot: Gaps typically hide boundary cases (caps, paused states, partial claims, minimums).

Try first:

Fuzz around max staking limits, partial redemptions, pause/unpause toggles.

Verify no fee accrual during disallowed states and no bypass via reentrancy to uncovered branches.

GitHub

7) V3TemporaryAdmin (0% covered)

Why hot: Pure governance/admin helper with zero coverage is a favorite spot for privilege or time-lock bypass mistakes.

Try first:

Attempt to exercise every guarded function with the wrong role/sender; check two-step confirmations and expirations.

Ensure no self-call or delegatecall path escalates privileges.

GitHub

8) PredepositGuarantee & CLProofVerifier (select lines uncovered)

Why hot: Proof verification edges are high-impact; a single unchecked boundary can greenlight bad state.

Try first:

Negative tests for malformed CL proofs, empty fields, max-size arrays.

Ensure the guarantee can’t be activated with an outdated or mismatched proof root.

GitHub